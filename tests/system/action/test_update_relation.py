from openslides_backend.action.generics.update import UpdateAction
from openslides_backend.action.util.action_type import ActionType
from openslides_backend.action.util.register import register_action
from openslides_backend.models import fields
from openslides_backend.services.postgresql.db_connection_handling import (
    get_new_os_conn,
)
from tests.patch_model_registry_helper import FakeModel, PatchModelRegistryMixin

from .base import BaseActionTestCase

collection_a = "fake_model_ur_a"
collection_b = "fake_model_ur_b"


def create_table_view() -> None:
    sql = f"""
    CREATE TABLE IF NOT EXISTS {collection_a}_t (
        id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY NOT NULL
    );

    CREATE TABLE IF NOT EXISTS {collection_b}_t (
        id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        {collection_a}_id integer REFERENCES {collection_a}_t(id) INITIALLY DEFERRED,
        {collection_a}_required_id integer REFERENCES {collection_a}_t(id) INITIALLY DEFERRED NOT NULL
    );

    DROP VIEW IF EXISTS "{collection_a}";
    CREATE VIEW "{collection_a}" AS SELECT *,
    (select b.id from {collection_b}_t b where b.{collection_a}_id = a.id) as {collection_b}_id,
    (select b.id from {collection_b}_t b where b.{collection_a}_required_id = a.id) as {collection_b}_required_id
    FROM {collection_a}_t a;

    DROP VIEW IF EXISTS "{collection_b}";
    CREATE VIEW "{collection_b}" AS SELECT * FROM {collection_b}_t;
    """
    with get_new_os_conn() as conn:
        with conn.cursor() as curs:
            curs.execute(sql)


class FakeModelURA(FakeModel):
    collection = "fake_model_ur_a"
    verbose_name = "fake model for cascade update a"
    id = fields.IntegerField()

    fake_model_ur_b_id = fields.RelationField(
        to={"fake_model_ur_b": "fake_model_ur_a_id"},
        is_view_field=True,
    )
    fake_model_ur_b_required_id = fields.RelationField(
        to={"fake_model_ur_b": "fake_model_ur_a_required_id"},
        is_view_field=True,
    )


class FakeModelURB(FakeModel):
    collection = "fake_model_ur_b"
    verbose_name = "fake model for cascade update b"
    id = fields.IntegerField()

    fake_model_ur_a_id = fields.RelationField(
        to={"fake_model_ur_a": "fake_model_ur_b_id"},
    )
    fake_model_ur_a_required_id = fields.RelationField(
        to={"fake_model_ur_a": "fake_model_ur_b_required_id"},
        required=True,
    )


@register_action("fake_model_ur_a.update", action_type=ActionType.BACKEND_INTERNAL)
class FakeModelURAUpdateAction(UpdateAction):
    model = FakeModelURA()
    schema = {}  # type: ignore
    skip_archived_meeting_check = True


class TestUpdateRelation(PatchModelRegistryMixin, BaseActionTestCase):
    @classmethod
    def setUpClass(cls) -> None:
        super().setUpClass()
        create_table_view()

    @classmethod
    def tearDownClass(cls) -> None:
        super().tearDownClass()
        with get_new_os_conn() as conn:
            with conn.cursor() as curs:
                curs.execute(
                    f"""
                    DROP TABLE {collection_b}_t CASCADE;
                    DROP TABLE {collection_a}_t CASCADE;
                    """
                )

    def setUp(self) -> None:
        super().setUp()
        self.set_models(
            {
                "fake_model_ur_a/1": {"fake_model_ur_b_id": 1},
                "fake_model_ur_b/1": {
                    "fake_model_ur_a_id": 1,
                    "fake_model_ur_a_required_id": 1,
                },
            }
        )

    def tearDown(self) -> None:
        super().tearDown()
        with self.connection.cursor() as curs:
            curs.execute(
                f"""
                TRUNCATE TABLE {collection_a}_t RESTART IDENTITY CASCADE;
                TRUNCATE TABLE {collection_b}_t RESTART IDENTITY CASCADE;
                """
            )

    def test_set_to_null(self) -> None:
        response = self.request(
            "fake_model_ur_a.update", {"id": 1, "fake_model_ur_b_id": None}
        )
        self.assert_status_code(response, 200)
        self.assert_model_exists("fake_model_ur_a/1", {"fake_model_ur_b_id": None})
        self.assert_model_exists("fake_model_ur_b/1", {"fake_model_ur_a_id": None})

    def test_set_required_to_null(self) -> None:
        response = self.request(
            "fake_model_ur_a.update", {"id": 1, "fake_model_ur_b_required_id": None}
        )
        self.assert_status_code(response, 400)
        self.assertIn(
            "Update of fake_model_ur_b/1: You try to set following required fields to an empty value: ['fake_model_ur_a_required_id']",
            response.json["message"],
        )
        self.assert_model_exists(
            "fake_model_ur_a/1", {"fake_model_ur_b_required_id": 1}
        )
        self.assert_model_exists(
            "fake_model_ur_b/1", {"fake_model_ur_a_required_id": 1}
        )

    def test_set_required_to_0(self) -> None:
        response = self.request(
            "fake_model_ur_a.update", {"id": 1, "fake_model_ur_b_required_id": 0}
        )
        self.assert_status_code(response, 400)
        self.assertIn(
            "Update of fake_model_ur_b/1: You try to set following required fields to an empty value: ['fake_model_ur_a_required_id']",
            response.json["message"],
        )
        self.assert_model_exists(
            "fake_model_ur_a/1", {"fake_model_ur_b_required_id": 1}
        )
        self.assert_model_exists(
            "fake_model_ur_b/1", {"fake_model_ur_a_required_id": 1}
        )
